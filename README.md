# Open Tracing Diagram
_Use traces to describe micro-services architecture._

## The problem
Microservices architectures are complex, it's never easy to write and maintain documention around it. Add asynchronous messages heaviliy used in reactive architecture, it becomes almost unrealistic to describe how a system is working. Even in monolith system, it's a challenge.

## The idea
With initiatives such as OpenTracing or OpenCensus, traces are easier and easier to get. So what about use traces to infer architecture ? However, unless we know exactly what we are looking for in alrge amount of traces, it's quite hard to extract the architecture: too much traces kill the traces in this case. We weed something on top to make some sense of them.

## The beginning of a solution

This project is a PoC that goes toward that goal. It builds a sequence diagram from [jaeger](https://www.jaegertracing.io/) traces and display it in a Grafana dashboard. It's not much but it can be useful.
**Disclaimer:** the initial idea is from: https://danlebrero.com/2017/04/06/documenting-your-architecture-wireshark-plantuml-and-a-repl/

## The Implementation

The transformation is done in Clojure. One file [handler.clj](https://github.com/alexvaut/OpenTracingDiagram/blob/master/jaeger2diag/src/jaeger2diag/handler.clj) of few hundreds lines, Swagger UI and Grafana source API included. Indeed, for Grafana to get access to the traces metadata, such as service name..., an API compatible with [Grafana simple json datasource](https://grafana.com/plugins/grafana-simple-json-datasource/installation) is needed.

The traces are generated by an extension of [akka.net](https://github.com/akkadotnet/akka.net) (akka.net is an actor framework for .NET derived from [akka](https://akka.io/) in java) that allows to easily trace all messages exchanged by actors: [akka.opentracing](https://github.com/alexvaut/akka.opentracing). The example is generating fake requests every 5 seconds that trigger jobs, sub processes, storage operations... No need to know the details, the idea is to discover and understand it from the traces.

### How to run it

```
git clone https://github.com/alexvaut/OpenTracingDiagram.git
cd OpenTracingDiagram
docker-compose up
```
Wait a bit for all the containers to be up and then:
- Browse to http://localhost:16686 to see traces in jeager.
- Browse to http://localhost:3000 to see the service transformation API in a Swagger UI (allow a couple of seconds for the Clojure Ring server to start).
- Browse to http://localhost:3001/d/mddcLWmWk/sequence-diagram-from-traces to see the grafana dashboard where sequence diagrams are displayed. Click on refresh (top-right of the grafana screen) to display a new sequence diagram: jaeger is returning random traces when filtering them, by default only one trace is displayed, you can increase this limit on the dashboard, it's a grafana variable.

## Screenshots

Commin soon...
